## Notes

I'm taking a break from this project a bit, and I know for sure that I will forget everything that I have worked on by the time I come back around to it. This README is my attempt to record down my progres so far, how things work, and what I plan to continue working on to complete the project.

### `deploy-cli`

`deploy-cli` is a command line tool that I created to help me set up the development environment and deploy the application, as there are multiple commands that need to be run to get everything set up.

The general flow is to set up the development environment (in the case of multipass, launching the VMs, and in the case of SSH, connecting to the raspberry Pis). Once it is set up, we set up the K3S servers with one master node and two worker nodes.

After that, we download some needed libraries (e.g. Helm, Cmctl, Go, etc.). Then we install `cert-manager` to handle the creation and rotation of SSL certificates. These certificates are needed for the following Vault installation. The Vault nodes need SSL certificates to both communicate amongst each other, as well as allowing a Vault client (like the CLI tool) to connect to the Vault server.

### `cert-manager` and auto-rotation

`cert-manager` creates a self-signed root CA, which is used to sign a TLS certificate that is used by the Vault nodes. As long as the root CA is trusted, then so will the TLS certificates be. (See `certificates.yaml` for the setup).

Now, the certificates generated by `cert-manager` do have an expiration period. I didn't want to have to handle manually rotating them and then updating the Vault processes with the new certificates, so I came up with a system that was automated.

First, I created a script `cert-watcher.sh`. Once the Vault pods are launched, a separate pod in the same namespace is launched that just runs this script. This pod is given limited access to the Kube cluster (see `cert-watcher.yaml`), and it inspects the secrets generated by `cert-manager` when creating the certificates. A fingerprint is generated for thsese secrets, then we go in a loop inspecting the secrets periodically. If the fingerprint changes, then we know that the Vault processes on each of the pods need a SIGHUP signal sent to them so they start using the new certificates. However, the mounted secret files on the Vault pods don't update immediately, so we instead use `kubectl` to run an inline script that creates a lock file in the Vault pod and then go in a loop until the secret has changed before sending the SIGHUP. The lock file prevents us from running this script multiple times.

Now, we will end up in a state where some pods are using the old certificate and others the new certificate. Until the original root CA actually expires, technically it is still trustworthy. So to be able to trust both root CAs, I use a `trust-bundle`. Part of the deployment script will copy the original root CA into a configmap, which the `trust-bundle` uses as part of its initialization. The trust-bundle is composed of two CAs, the new CA as well as the expiring CA. Whenever we detect a rotation with the `cert-watcher`, it copies over the "new CA" into the "expiring CA" and then copies over the actual new CA into the "new CA" slot. The trust bundle can be mounted into pods, allowing you to have a constantly up to date trust store of CAs.

### Next Steps

The next step is figuring out deployment of a database server. I'm wanting to use Cockroach to do this and the challenging part is figuring out the TLS certificates for this. Fortunately, Cockroach does have [documentation](https://www.cockroachlabs.com/docs/v24.3/create-security-certificates-openssl) on this, but it's a pain to figure out. I'm trying to use Vault to create the certificates, then use the agent sidecar injector to inject it into the Cockroach pods.

Once that is done, we can then use Vault to create auto-rotating database credentials.